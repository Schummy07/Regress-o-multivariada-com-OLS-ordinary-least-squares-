# -*- coding: utf-8 -*-
"""rotina_DoE

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11exOaqyzWpQjWouBpRTAsgHp_XjdG-Yg
"""

import math as mt
import pandas as pd
import seaborn as sns
import scipy as scp
import numpy as np
import matplotlib.pyplot as plt

def DoE(X, y, SQep, gl_SQep):

  # função feita para replicar os cálculos exatos desceritos no livro "Planejamento Fatorial em Química: Maximizando a Obtenção de resultados"
  # Nessa função o cálculo da soma quadrática do erro puro e seus graus de liberdade devem ser calculados separadamente em excel
  # A função recebe 4 parâmetros de entrada:
  #  - X: a matriz geratriz com os parâmetros experimentais normalizados
  #  - y: as respostas experimentais
  #  - SQep: a soma quadrática do erro puro (quando não houer o parâmetro inserido deve ser 0 )
  #  - gl_sSQep: os graus de liberdade da soma quadrática do erro puro (quando não houer o parâmetro inserido deve ser 0 )
  #

  #calculo da ponderação dos coeficientes (pond) e dos coeficientes de regressão (b)
  xxt = np.linalg.inv(X.T .dot(X))
  #pond = [[xxt[i][j] for j in range(0,len(xxt[i])) if i ==j ] for i in range(0,len(xxt))]
  pond = np.diag(xxt)
  #coeficientes de regressão (b)
  b = np.linalg.inv(X.T.dot(X)) .dot(X.T) .dot(y)
  #calculo dos resultados previstos pelo modelo de regressão calculado (prev)
  prev = X.dot(b)

  # tabela resultados obtidos, resultados previstos, resíduos (obtidos menos previstos) e resíduos²
  tab = pd.DataFrame(data = {"Resultados":y,"Prev":prev,"Res":y-prev,"Res²":(y-prev)**2})

  #cáculo das somas quadráticas (SQ's)
  SQR = ((tab["Prev"]-tab["Resultados"].mean())**2).sum()
  SQres = tab["Res²"].sum()
  SQT = SQR + SQres
  SQep = SQep
  SQfaj = SQres - SQep

  #Graus de liberdade
  GL = [len(b)-1, len(X)-len(b),(len(b)-1)+(len(X)-len(b)),gl_SQep,len(X)-gl_SQep-len(b)]

  #montagem da tabela ANOVA e Médias Quadráticas
  ANOVA = pd.DataFrame(data = {"SQ":[SQR, SQres, SQT, SQep, SQfaj],"GL":GL}, index = ["Regressão","Resíduo","Total","Erro_Puro","Falta_Ajuste"])
  ANOVA["MQ"] = ANOVA["SQ"]/ANOVA["GL"]

  #Coeficientes de correlação na tabela ANOVA
  ANOVA = pd.concat([ANOVA,pd.DataFrame([[SQR/SQT,"R", (SQR/SQT)**0.5]], index = ["R_quad"], columns = ANOVA.columns)])
  ANOVA = pd.concat([ANOVA,pd.DataFrame([[(SQT-SQep)/SQT, "R_max", ((SQT-SQep)/SQT)**0.5]], index = ["R_quad_m"], columns = ANOVA.columns)])

  #Testes de inferência estatística
  F_R = (SQR/(len(b)-1))/(SQres/(len(X)-len(b)))
  F_R_tab = scp.stats.f.ppf(0.95, len(b)-1, (len(X)-len(b)))
  F_faj = ["-" if SQep ==0 else (SQfaj/(len(X)-gl_SQep-len(b)))/(SQep/gl_SQep)][0]
  F_faj_tab = ["-" if SQep ==0 else scp.stats.f.ppf(0.95,(len(X)-gl_SQep-len(b)), gl_SQep)][0]

  #Inserção dos testes de inferência na tabela ANOVA
  ANOVA["Teste_F"] = [F_R,"-","-","-",F_faj,"-","-"]
  ANOVA["F Tabelado 95%"] = [F_R_tab,"-","-","-",F_faj_tab,"-","-"]


  #cálculo das variâncias dos coeficientes de regressão, dos erros e dos intervalos de confiança
  var = pond * (SQres/(len(b)-1))
  erro = var**0.5
  int_c_res = erro * scp.stats.t.ppf(0.975, df = len(X)-len(b) -1)
  int_c_faj = erro * scp.stats.t.ppf(0.975, len(X)-gl_SQep-len(b))

  #tabela com os coeficientes, erros e intervalos de confiança (para os resíduos e para a falta de ajuste)
  COEF = pd.DataFrame(data = {"coef":b, "var":var, "erro":erro, "int_c_res":int_c_res, "int_c_faj":int_c_faj}, index = X.columns)

  # Plot dos gráficos
  gs = plt.GridSpec(1,3, wspace = .15)
  figura1 = plt.figure(figsize = (16,4))

  ax1 = figura1.add_subplot(gs[0,0])
  ax2 = figura1.add_subplot(gs[0,1])
  ax3 = figura1.add_subplot(gs[0,2])

  #Gráfico dos coeficientes de regressão com os intervalos de confiaça para o resíduo
  ax1.scatter(COEF.index,COEF["coef"])
  ax1.scatter(COEF.index, COEF["coef"]+ int_c_res, edgecolors= "none", s = 20, c = "red")
  ax1.scatter(COEF.index, COEF["coef"]- int_c_res, edgecolors= "none", s = 20, c = "red")
  ax1.hlines(0, xmin = COEF.index[0], xmax=COEF.index[-1], colors = "black")
  ax1.set_title("Coeficientes de regressão")

  # histograma dos resíduos
  sns.histplot(data = tab, x = "Res", bins = 10, kde = True, ax = ax2)
  ax2.set_title("Histograma dos Resíduos")

  # gráfico das respostas obtidas experimentalmente vs respostas previstas pelo modelo de regressão
  sns.regplot(data = tab, x ="Resultados", y = "Prev", ax = ax3)

  # output em excel com as respostas previstas "tab", a tabela anova "ANOVA" e os coeficientes de regressão "COEF"
  with pd.ExcelWriter("output.xlsx") as writer:
    tab.to_excel(writer, sheet_name = "Resultados_regressão")
    ANOVA.to_excel(writer, sheet_name = "ANOVA")
    COEF.to_excel(writer, sheet_name = "Coeficientes")

  plt.show()

  return(tab,ANOVA, COEF)

def DoE_auto(x,y):

  #rotina que calcula os foecifientes de regressão e os parametros da tabela anova sem levar em conta a falta de ajuste e o erro puto
  #deve ser usada para calcular os coeficientes de regressão e automaticamente eliminar aqueles que são insignificantes
  #após a eliminação dos coeficientes insignificantes, um novo cálculo deve ser realizado

  #cálculo da ponderação e dos coeficientes de regressão
  xxt = np.linalg.inv(x.T.dot(x))
  pond = np.diag(xxt)
  b = xxt.dot(x.T).dot(y)

  #cálculo dos valores previstos
  prev = x.dot(b)
  PREV = pd.DataFrame(data = {"Resultados": y, "Prev": prev, "Residuos": y - prev, "Residuos²": (y - prev)**2})

  #Cálculo da soma quatrática da regressão, dos resíduos e da soma quadrática total
  SQR = ((PREV["Prev"]-PREV["Resultados"].mean())**2).sum()
  SQres = PREV["Residuos²"].sum()

  #cálculo das médias quadráticas
  gl_R = len(b)-1
  gl_res = len(x) - len(b)

  #calculo da variância, erro e intervalos de confiança
  var = pond * (SQres/gl_res)
  erro = var**0.5
  int_c = erro * scp.stats.t.ppf(0.975,gl_res-1)

  Ver = [SQR, SQres, gl_R, gl_res]

  #tabela com os coeficientes e as medidas de variância, erro e intervalo de confiança para os resíduos
  COEF = pd.DataFrame(data = {"coef": b, "var": var, "erro": erro, "int_c": int_c}, index = x.columns)


  return(PREV,COEF)

def super_DoE(x,y):

  #cópia da matriz original para preservar os dados
  x_c = x.copy()

  # cálculo dos valores previstos pelo modelo, parâmetros de validação estatística e coeficientes de regressão
  prev, reg = DoE_auto(x_c, y)

  #verificação dos coeficientes irrelevantes e indexação do mais insignificantes entre eles, ou seja: com a maior discrepância entre o valor do coeficiente e seu respectivo
  #intervalo de confiança
  reg["dif"] = ((reg["coef"])**2)**.5 - reg["int_c"]
  minimo = reg["dif"].min()
  indice = reg["dif"].idxmin()

  #converssão dos valores para uma lista
  # a lista é criada para adicionar os resultados das novas regressões após a exclusão dos coeficientes insignificantes
  lista_reg = [reg.to_numpy().tolist()]
  reg_ind = [reg.index.to_numpy().tolist()]
  lista_prev = [prev.to_numpy().tolist()]

  #o valor mínimo menor que zero indica que ainda existem coeficientes insignificantes
  while minimo < 0:
    #exclusão do coeficiente menos significante
    x_c = x_c.drop(indice, axis = 1)

    #cálculo do novo modelo de regressão
    prev, reg = DoE_auto(x_c, y)

    # nova verificação de confiabilidade dos coeficientes
    reg["dif"] = ((reg["coef"])**2)**.5 - reg["int_c"]

    #inserção dos novos valores para as listas
    lista_reg.append(reg.to_numpy().tolist())
    lista_prev.append(prev.to_numpy().tolist())
    reg_ind.append(reg.index.to_numpy().tolist())

    # verificação se há coeficientes insignificantes
    minimo = reg["dif"].min()
    indice = reg["dif"].idxmin()

  #figura aonde seão exibidos os resultados
  figura, axis = plt.subplots(len(lista_reg), 3, figsize = (16,3*len(lista_reg)) )
  figura.subplots_adjust(hspace = 0.3)

  #ajuste das dimensões das figuras caso não tenham coeficientes eliminados (apenas uma linha)
  if len(lista_reg) == 1:
      axis = np.expand_dims(axis, axis=0)

  for i in range(0,len(lista_reg)):

    #criação dos dataframes a partir das listas para plotar os resultados
    reg_plot = pd.DataFrame(data = lista_reg[i], index = reg_ind[i], columns = reg.columns)
    prev_plot = pd.DataFrame(data = lista_prev[i], columns = prev.columns)


    #plot dos coeficientes e seus intervalos de confiança
    axis[i,0].scatter(reg_plot.index, reg_plot["coef"])
    axis[i,0].scatter(reg_plot.index, reg_plot["coef"] - reg_plot["int_c"], s = 15, c = "red")
    axis[i,0].scatter(reg_plot.index, reg_plot["coef"] + reg_plot["int_c"], s = 15, c = "red")
    axis[i,0].hlines(y = 0, xmin=reg_plot.index[0], xmax=reg_plot.index[-1], color = "black")

    #plot dos histogramas dos resíduos
    sns.histplot(x = prev_plot["Residuos"], bins = 10, ax = axis[i,1], kde = True)

    #plot dos resultados previstos x calculados
    sns.regplot(data = prev_plot, x = "Resultados", y = "Prev", ax = axis[i,2])

  #exportação dos resultados para um arquivo em excel
  with pd.ExcelWriter("Resultados_DoE.xlsx") as writer:
    for i in range(0, len(lista_reg)):
      df = pd.DataFrame(data = lista_reg[i], index = reg_ind[i], columns = reg.columns)
      df.to_excel(writer, sheet_name = f"modelo{i}")

      df=pd.DataFrame(data = lista_prev[i], columns = prev.columns)
      df.to_excel(writer, sheet_name = f"previsão{i}")


  return(lista_reg, lista_prev)

def replicas(x, y ):
  conj_repli = []
  ind_repli = []
  teste = x.copy()
  indices_processados = set()

  for i in teste.index:
    if i in indices_processados:
      continue


    igual = teste.loc[i]
    boleano = teste.eq(igual)
    indice = boleano[boleano.all(True)].index

    if len(indice) > 1:

      conj_repli.append(y.loc[indice].to_numpy().tolist())
      ind_repli.append(indice)
      indices_processados.update(indice.values.tolist())

  replicas = pd.DataFrame(data = conj_repli).T
  descritivo = replicas.describe().T.copy()
  descritivo["var"] = descritivo["std"]**2
  descritivo["gl"] = descritivo["count"]-1
  descritivo["SQ_ep"] = descritivo["var"]*descritivo["gl"]

  return(conj_repli, ind_repli, replicas, descritivo)